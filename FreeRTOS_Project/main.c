/* Kernel includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "event_groups.h"
#include "semphr.h"

/* MCAL includes. */
#include "gpio.h"
#include "uart0.h"
#include "adc.h"
#include "tm4c123gh6pm_registers.h"

#define mainSW2_INTERRUPT_BIT ( 1UL << 0UL )  /* Event bit 0, which is set by a SW2 Interrupt. */
#define mainSW1_INTERRUPT_BIT ( 1UL << 1UL )  /* Event bit 1, which is set by a SW1 Interrupt. */

#define NUMBER_OF_ITERATIONS_PER_ONE_MILI_SECOND 369
#define RUNTIME_MEASUREMENTS_TASK_PERIODICITY (1000U)
#define MAXVOLTAGEADC 3.3f
#define MAXTEMPERATURE 45
#define ISDRIVER 'D'
#define ISPASSENGER 'P'

/*************************** Variables ***************************/

/* General Variables */
uint8 DriverState =0 ;
uint8 PassengerState =0 ;

UserHeatInput DesiredTempDriver;   /* Carries Desired Value entered by user */
UserHeatInput DesiredTempPassenger;

float32 CurrentTempDriver; /* Carries Value generated by ADC */
float32 CurrentTempPassenger;

HeatIntensity heatIntensity;


/* Runtime measurements */
uint32 ullTasksOutTime[13];
uint32 ullTasksInTime[13];
uint32 ullTasksExecutionTime[13];


/* Semaphors & Mutexes */
xSemaphoreHandle CurrentTempMutexDriver;
xSemaphoreHandle CurrentTempMutexPassenger;

xSemaphoreHandle DesiredTempMutexDriver;
xSemaphoreHandle DesiredTempMutexPassenger;
xSemaphoreHandle UARTMutex;


/* LockTime variables per task for each resource */
TickType_t CurrentTempReadingTaskDriverLT            = 0;
TickType_t CurrentTempReadingTaskPassengerLT         = 0;

TickType_t DesiredTempSettingTaskDriverLT            = 0;
TickType_t DesiredTempSettingTaskPassengerLT         = 0;

TickType_t CurrentTempControllerTaskDriverLT         = 0;
TickType_t CurrentTempControllerTaskPassengerLT      = 0;

TickType_t DesiredTempControllerTaskDriverLT         = 0;
TickType_t DesiredTempControllerTaskPassengerLT      = 0;

TickType_t DesiredTempDisplayTaskDriverLT            = 0;
TickType_t DesiredTempDisplayTaskPassengerLT         = 0;

TickType_t UARTDisplayTaskDriverLT                   = 0;
TickType_t UARTDisplayTaskPassengerLT                = 0;

TickType_t UARTRunTimeMeasurementsTaskLT             = 0;
TickType_t UARTOneTimeRunTimeMeasurementsTaskLT      = 0;
/************************* Variables END *************************/


/***************** Task Handles *****************/
TaskHandle_t vTemperatureSetTaskDrivertHandle     ;
TaskHandle_t vTemperatureSetTaskPassengertHandle  ;

TaskHandle_t vTemperatureReadTaskDriverHandle     ;
TaskHandle_t vTemperatureReadTaskPassengerHandle  ;

TaskHandle_t vHeating_CoolingTaskDriverHandle     ;
TaskHandle_t vHeating_CoolingTaskPassengerHandle  ;

TaskHandle_t vDisplayTaskDriverHandle             ;
TaskHandle_t vDisplayTaskPassengerHandle          ;

TaskHandle_t vControllerTaskDriverHandle          ;
TaskHandle_t vControllerTaskPassengerHandle       ;

TaskHandle_t vRunTimeMeasurementsTaskHandle       ;


/***************** Events *****************/
EventGroupHandle_t eventTempSet;


/***************** FreeRTOS Queues *****************/
QueueHandle_t Controller_HeatingDriver;
QueueHandle_t Controller_HeatingPassenger;

QueueHandle_t Controller_DisplayDriver;
QueueHandle_t Controller_DisplayPassenger;

QueueHandle_t Reading_DisplayDriver;
QueueHandle_t Reading_DisplayPassenger;

/***************** Tasks Prototypes *****************/

/* Description:   Carries out Runtime Measurements.
 * Priority:      Medium, as accurate temperature data is crucial for control decisions.
 * Dependencies:  None.
 * Communication: None. */
void vRunTimeMeasurementsTask(void *pvParameters);


/* Description:   Reads temperature data from sensors placed inside the system.
 * Priority:      Medium, as accurate temperature data is crucial for control decisions.
 * Dependencies:  None.
 * Communication: Shares temperature data with the Control Task and Display Task.*/
void vTempReadingTask(void *pvParameters); /* Driver -> ADC0 ... Passenger -> ADC1 */


/* Description: establishes the desired temperature within the system.
 * Priority: High, as the desired value is the base for the system operation.
 * Dependencies: None.
 * Communication: Shares temperature desired value with the Control and Display Tasks.*/
void vTempSettingTask(void *pvParameters);

/*Description: Determines actions based on the desired temperature and current temperature, controlling the heating or cooling systems.
 *Priority: Medium, as it directly influences the system environment.
 *Dependencies: Depends on Temperature Reading and Desired Temperature Setting Tasks for input.
 *Communication: Reads Temperature Data from vTempReading and Desired Temp Value from vTempSetting Task
 *               and Sends heating intensity(State) to the Heating-Cooling Task. */
void vControllerTask(void *pvParameters);


/*Description: Executes commands from the Control Task to activate heating or cooling systems.
 *Priority: Medium, as it directly impacts the system temperature.
 *Dependencies: Depends on the Control Task.
 *Communication: Reads Heat intensity (State).*/
void vHeating_CoolingTask(void *pvParameters);


/*Description: Manages the display interface showing current temperature and system status. Priority: Low, as it's not critical for real-time control.
 *Priority: Low, as a small delay in display is tolerable.
 *Dependencies: Depends on data from ControlTask, Reading Task, TempSetting Task .
 *Communication: Reads Temperature Data from vTempReading and Desired Temp Value.*/
void vDisplayTask(void *pvParameters);


/***************** Auxiliary Methods/Handlers *****************/
void Delay_MS(unsigned long long n){
    volatile unsigned long long count = 0;
    while(count++ < (NUMBER_OF_ITERATIONS_PER_ONE_MILI_SECOND * n) );
}

void GPIOPortF_Handler(void){
    BaseType_t pxHigherPriorityTaskWoken = pdFALSE;
    if(GPIO_PORTF_RIS_REG & (1<<0)){           /* PF0 handler code for the DRIVER SEAT  */
        xEventGroupSetBitsFromISR(eventTempSet, mainSW2_INTERRUPT_BIT,&pxHigherPriorityTaskWoken);
        DriverState=(DriverState++)%4;
        GPIO_PORTF_ICR_REG   |= (1<<0);       /* Clear Trigger flag for PF0 (Interrupt Flag) */
    }
    else if(GPIO_PORTF_RIS_REG & (1<<4)){      /* PF4 handler code for the PASSENGER SEAT */
        xEventGroupSetBitsFromISR(eventTempSet, mainSW1_INTERRUPT_BIT,&pxHigherPriorityTaskWoken);
        PassengerState=(PassengerState++)%4;
        GPIO_PORTF_ICR_REG   |= (1<<4);       /* Clear Trigger flag for PF4 (Interrupt Flag) */
    }
}

void GPIOPortB_Handler(void){
    BaseType_t pxHigherPriorityTaskWoken = pdFALSE;
    if(GPIO_PORTB_RIS_REG & (1<<0)){           /* PF0 handler code for the DRIVER SEAT  */
        xEventGroupSetBitsFromISR(eventTempSet, mainSW2_INTERRUPT_BIT,&pxHigherPriorityTaskWoken);
        DriverState=(DriverState++)%4;
        GPIO_PORTB_ICR_REG   |= (1<<0);       /* Clear Trigger flag for PF0 (Interrupt Flag) */
    }
}

/* The HW setup function */
static void prvSetupHardware( void );

int main(){
    /* Setup the hardware for use with the Tiva C board. */
    prvSetupHardware();


    /************** MUTEX CREATION **************/
    CurrentTempMutexDriver       = xSemaphoreCreateMutex();
    CurrentTempMutexPassenger    = xSemaphoreCreateMutex();

    DesiredTempMutexDriver       = xSemaphoreCreateMutex();
    DesiredTempMutexPassenger    = xSemaphoreCreateMutex();

    UARTMutex                    = xSemaphoreCreateMutex();


    /************** QUEUE CREATION **************/
    Controller_HeatingDriver    = xQueueCreate(1, sizeof(uint8));
    Controller_HeatingPassenger = xQueueCreate(1, sizeof(uint8));

    Controller_DisplayDriver    = xQueueCreate(1, sizeof(uint8));
    Controller_DisplayPassenger = xQueueCreate(1, sizeof(uint8));

    Reading_DisplayDriver       = xQueueCreate(1, sizeof(uint8));
    Reading_DisplayPassenger    = xQueueCreate(1, sizeof(uint8));


    /************** EVENT CREATION **************/
    eventTempSet=xEventGroupCreate();


    /****************************** Task Creation ***************************************/

    xTaskCreate(vRunTimeMeasurementsTask, "vRunTimeMeasurementsTask", 256, NULL, 1, &vRunTimeMeasurementsTaskHandle);

    vTaskSetApplicationTaskTag( vRunTimeMeasurementsTaskHandle, (void *)1 );


    /* Create Tasks here */
    xTaskCreate(vTempSettingTask,                    /* Pointer to the function that implements the task. */
                    "SetTempForDriver",                     /* Text name for the task.  This is to facilitate debugging only. */
                    256,                                    /* Stack depth - most small microcontrollers will use much less stack than this. */
                    NULL,                                   /* Specify this is for Driver */
                    (configMAX_PRIORITIES-1),               /* This task will run at priority 4. */
                    &vTemperatureSetTaskDrivertHandle);     /* We are using the task handle. */

    vTaskSetApplicationTaskTag( vTemperatureSetTaskDrivertHandle, (void *)2 );



    xTaskCreate( vTempSettingTask, "SetTempForPassenger", 256, NULL, (configMAX_PRIORITIES-1), &vTemperatureSetTaskPassengertHandle );

    vTaskSetApplicationTaskTag( vTemperatureSetTaskPassengertHandle, (void *)3 );



    xTaskCreate( vTempReadingTask, "ReadTempForDriver", 256, ((void*)'D'), 3, &vTemperatureReadTaskDriverHandle) ;

    vTaskSetApplicationTaskTag( vTemperatureReadTaskDriverHandle, (void *)4 );



    xTaskCreate( vTempReadingTask, "ReadTempForPassenger", 256, ((void*)'P'), 3, &vTemperatureReadTaskPassengerHandle );

    vTaskSetApplicationTaskTag( vTemperatureReadTaskPassengerHandle, (void *)5 );



    xTaskCreate( vHeating_CoolingTask, "HeatingForDriver", 256, ((void*)'D'), 2, &vHeating_CoolingTaskDriverHandle );

    vTaskSetApplicationTaskTag( vHeating_CoolingTaskDriverHandle, (void *)6 );



    xTaskCreate( vHeating_CoolingTask, "HeatingForPassenger", 256, ((void*)'P'), 2, &vHeating_CoolingTaskPassengerHandle );

    vTaskSetApplicationTaskTag( vHeating_CoolingTaskPassengerHandle, (void *)7 );



    xTaskCreate( vDisplayTask, "DisplayForDriver", 256, ((void*)'D'), 1, &vDisplayTaskDriverHandle );

    vTaskSetApplicationTaskTag( vDisplayTaskDriverHandle, (void *)8 );



    xTaskCreate( vDisplayTask, "DisplayForPassenger", 256, ((void*)'P'), 1, &vDisplayTaskPassengerHandle);

    vTaskSetApplicationTaskTag( vDisplayTaskPassengerHandle, (void *)9 );



    xTaskCreate( vControllerTask, "ControlForDriver" , 256, ((void*)'D'), 2, &vControllerTaskDriverHandle );

    vTaskSetApplicationTaskTag( vControllerTaskDriverHandle, (void *)10 );



    xTaskCreate( vControllerTask, "ControlForPassenger" , 256, ((void*)'P'), 2, &vControllerTaskPassengerHandle );

    vTaskSetApplicationTaskTag( vControllerTaskPassengerHandle, (void *)11 );


	/* Now all the tasks have been started - start the scheduler.

	NOTE : Tasks run in system mode and the scheduler runs in Supervisor mode.
	The processor MUST be in supervisor mode when vTaskStartScheduler is called.
	The demo applications included in the FreeRTOS.org download switch to
	supervisor mode prior to main being called.  If you are not using one of
	these demo application projects then ensure Supervisor mode is used here. */ 
	vTaskStartScheduler();
	
	/* Should never reach here!  If you do then there was not enough heap
	available for the idle task to be created. */
	for (;;);
}


static void prvSetupHardware( void ){
	/* Place here any needed HW initialization such as GPIO, UART, etc.  */

    GPIO_BuiltinButtonsLedsInit();/*->Note that for the purpose of testing only the heater level shall control the LED :
                                    i. Green color indicates low intensity.
                                    ii. Blue color indicates medium intensity.
                                    iii. Cyan color indicates high intensity.
                                    ->2 buttons in the car's middle console where each button is used to control one of the two seat
                                    heaters.*/
    GPIO_SW1EdgeTriggeredInterruptInit ();
    GPIO_SW2EdgeTriggeredInterruptInit ();

    GPIO_ExternalLEDSPASSENGER();

    GPIO_ExternalButton(); //button on steering wheel for driver
    GPIO_ExtraExternalButtonTriggeredInterruptInit();

    GPTM_WTimer0Init();

    UART0_Init();/*The current temperature, the heating level, and the heater state should be displayed on the screen by sending it through the UART.*/

    ADC_Init();/*The temperature sensor shall be connected to the ADC so that the current temperature is measured correctly*/
}

void vTempReadingTask(void *pvParameters){

    const TickType_t xDelay = pdMS_TO_TICKS(150);
    TickType_t xStartTime, xEndTime;

    uint8 SeatSelect = (uint8)pvParameters;
    float32 adc_value;

    for(;;){

        adc_value = ((float32)ADC0_readChannel())*((float)MAXTEMPERATURE/MAXVOLTAGEADC);
        xStartTime = xTaskGetTickCount();

        if(SeatSelect==ISDRIVER){

             if (xSemaphoreTake(CurrentTempMutexDriver, portMAX_DELAY) == pdTRUE){
                 CurrentTempDriver=adc_value;
                 xSemaphoreGive(CurrentTempMutexDriver);  /* Release the resource */
             }
             xEndTime = xTaskGetTickCount();
             CurrentTempReadingTaskDriverLT += xEndTime - xStartTime;

             xQueueSend(Reading_DisplayDriver,&adc_value, portMAX_DELAY) ;
        }
        else if(SeatSelect==ISPASSENGER){
            if (xSemaphoreTake(CurrentTempMutexPassenger, portMAX_DELAY) == pdTRUE){
                CurrentTempPassenger=adc_value;
                xSemaphoreGive(CurrentTempMutexPassenger);  /* Release the resource */
            }
            xEndTime = xTaskGetTickCount();
            CurrentTempReadingTaskPassengerLT += xEndTime - xStartTime;

            xQueueSend(Reading_DisplayPassenger,&adc_value, portMAX_DELAY) ;
        }

        vTaskDelay(xDelay);
    }
}


void vTempSettingTask(void *pvParameters){
    EventBits_t xEventGroupValue;
    const EventBits_t xBitsToWaitFor = ( mainSW1_INTERRUPT_BIT | mainSW2_INTERRUPT_BIT);

    TickType_t xStartTime, xEndTime;

    for (;;){
        /* Block to wait for event bits to become set within the event group. */
        xEventGroupValue = xEventGroupWaitBits( eventTempSet,    /* The event group to read. */
                                                xBitsToWaitFor,  /* Bits to test. */
                                                pdTRUE,          /* Clear bits on exit if the unblock condition is met. */
                                                pdFALSE,         /* Dont't Wait for all bits. */
                                                portMAX_DELAY);  /* Don't time out. */

        /* In case PF4 edge triggered interrupt occurred, it will set event 1 bit */
        if ((xEventGroupValue & mainSW1_INTERRUPT_BIT) != 0){ /*Driver*/
            xStartTime = xTaskGetTickCount();

            if (xSemaphoreTake(DesiredTempMutexDriver, portMAX_DELAY) == pdTRUE){
                switch (PassengerState){    /* Heat Level */
                    case 0: DesiredTempDriver=OFF;       break;
                    case 1: DesiredTempDriver=LOW;       break;
                    case 2: DesiredTempDriver=MEDIUM;    break;
                    case 3: DesiredTempDriver=HIGH;      break;
                }
                xSemaphoreGive(DesiredTempMutexDriver);  /* Release the resource */
            }
            xEndTime = xTaskGetTickCount();
            DesiredTempSettingTaskDriverLT += xEndTime - xStartTime;
        }

        /* In case PF0 edge triggered interrupt occurred, it will set event 1 bit */
        if ((xEventGroupValue & mainSW2_INTERRUPT_BIT) != 0){ /*Passenger*/
            xStartTime = xTaskGetTickCount();

            if (xSemaphoreTake(DesiredTempMutexPassenger, portMAX_DELAY) == pdTRUE){
                switch (PassengerState){
                    case 0: DesiredTempPassenger=OFF;       break;
                    case 1: DesiredTempPassenger=LOW;       break;
                    case 2: DesiredTempPassenger=MEDIUM;    break;
                    case 3: DesiredTempPassenger=HIGH;      break;
                }
                xSemaphoreGive(DesiredTempMutexPassenger);  /* Release the resource */
            }
            xEndTime = xTaskGetTickCount();
            DesiredTempSettingTaskPassengerLT += xEndTime - xStartTime;
        }
    }
}

void vControllerTask(void *pvParameters){
    const TickType_t xDelay = pdMS_TO_TICKS(100);
    TickType_t xStartTime, xEndTime;

    float32 CurrentTemp = 0;
    UserHeatInput DesiredTemp = OFF;

    uint8 SeatSelect = (uint8)pvParameters;

    for(;;){

        /************************** DRIVER ********************************/
        if(SeatSelect==ISDRIVER){
            /********** ACQUIRE CURRENT TEMP FOR DRIVER ********/
            xStartTime = xTaskGetTickCount();

            if (xSemaphoreTake(CurrentTempMutexDriver, portMAX_DELAY) == pdTRUE){
                CurrentTemp = CurrentTempDriver;
                 xSemaphoreGive(CurrentTempMutexDriver);  /* Release the resource */
             }

            xEndTime = xTaskGetTickCount();
            CurrentTempControllerTaskDriverLT += xEndTime - xStartTime;
            /************************** END ********************************/

            /*************** ACQUIRE DESIRED TEMP FOR DRIVER **************/
            xStartTime = xTaskGetTickCount();

            if (xSemaphoreTake(DesiredTempMutexDriver, portMAX_DELAY) == pdTRUE){
                DesiredTemp = DesiredTempDriver;
                xSemaphoreGive(DesiredTempMutexDriver);  /* Release the resource */
            }

            xEndTime = xTaskGetTickCount();
            DesiredTempControllerTaskDriverLT += xEndTime - xStartTime;

            /************************** END ********************************/

            if(CurrentTemp < 5 || CurrentTemp > 40){
                heatIntensity=ERROR;
                //EEPROMWrite((uint32)Reading, 1, 1) ;
            }
            else if((DesiredTemp - CurrentTemp) >= 10){
                heatIntensity=HIGHINTENSITY;
            }
            else if((DesiredTemp - CurrentTemp) >= 5 && (DesiredTemp - CurrentTemp) < 10  ){
                heatIntensity=MEDIUMINTENSITY;
            }
            else if((DesiredTemp - CurrentTemp) >= 2 && (DesiredTemp - CurrentTemp) < 5){
                heatIntensity=LOWINTENSITY;
            }
            else if((CurrentTemp - DesiredTemp) >= 0 ){
                heatIntensity=OFF;
            }

            xQueueSend(Controller_HeatingDriver,&heatIntensity, portMAX_DELAY) ;

            xQueueSend(Controller_DisplayDriver,&heatIntensity, portMAX_DELAY);     /* Send Heat State to Display */
        }

        /************************** END DRIVER ********************************/

        else if(SeatSelect==ISPASSENGER){
            /************ ACQUIRE CURRENT TEMP FOR PASSENGER ************/
            xStartTime = xTaskGetTickCount();

            if (xSemaphoreTake(CurrentTempMutexPassenger, portMAX_DELAY) == pdTRUE){
                CurrentTemp=CurrentTempPassenger;
                xSemaphoreGive(CurrentTempMutexPassenger);  /* Release the resource */
            }

            xEndTime = xTaskGetTickCount();
            CurrentTempControllerTaskPassengerLT += xEndTime - xStartTime;
            /************************** END ********************************/

            /*************** ACQUIRE DESIRED TEMP FOR DRIVER **************/
            xStartTime = xTaskGetTickCount();

            if (xSemaphoreTake(DesiredTempMutexPassenger, portMAX_DELAY) == pdTRUE){
                DesiredTemp = DesiredTempPassenger;
                xSemaphoreGive(DesiredTempMutexPassenger);  /* Release the resource */
            }

            xEndTime = xTaskGetTickCount();
            DesiredTempControllerTaskPassengerLT += xEndTime - xStartTime;

            /************************** END ********************************/


            if(CurrentTemp < 5 || CurrentTemp > 40){
                heatIntensity=ERROR;
                //EEPROMWrite((uint32)Reading, 1, 1) ;
            }
            else if((DesiredTemp - CurrentTemp) >= 10){
                heatIntensity=HIGHINTENSITY;
            }
            else if((DesiredTemp - CurrentTemp) >= 5 && (DesiredTemp - CurrentTemp) < 10  ){
                heatIntensity=MEDIUMINTENSITY;
            }
            else if((DesiredTemp - CurrentTemp) >= 2 && (DesiredTemp - CurrentTemp) < 5){
                heatIntensity=LOWINTENSITY;
            }
            else if((CurrentTemp - DesiredTemp) >= 0 ){
                heatIntensity=OFF;
            }

            xQueueSend(Controller_HeatingPassenger,&heatIntensity, portMAX_DELAY) ;

            xQueueSend(Controller_DisplayPassenger,&heatIntensity, portMAX_DELAY);     /* Send Heat State to Display */
        }


        vTaskDelay(xDelay);
    }
}


void vHeating_CoolingTask(void *pvParameters){

    uint8 SeatSelect = (uint8)pvParameters;
    HeatIntensity selectedHeatingIntensity;

    for(;;){

        if(SeatSelect==ISDRIVER){
            xQueueReceive(Controller_HeatingDriver, &selectedHeatingIntensity, portMAX_DELAY);

            switch(selectedHeatingIntensity){
                case ERROR:
                    GPIO_RedLedOn();
                    GPIO_BlueLedOff();
                    GPIO_GreenLedOff();
                    break;

                case INTENSITYOFF:
                    GPIO_RedLedOff();
                    GPIO_BlueLedOff();
                    GPIO_GreenLedOff();
                    break;

                case LOWINTENSITY:
                    GPIO_RedLedOff();
                    GPIO_BlueLedOff();
                    GPIO_GreenLedOn();
                    break;

                case MEDIUMINTENSITY:
                    GPIO_RedLedOff();
                    GPIO_BlueLedOn();
                    GPIO_GreenLedOff();
                    break;

                case HIGHINTENSITY:
                    GPIO_RedLedOff();
                    GPIO_BlueLedOn();
                    GPIO_GreenLedOn();
                    break;
            }
        }
        else if(SeatSelect==ISPASSENGER){
            /*PB0 -> BLUE
              PB1 -> GREEN
              PB2 -> RED
             */
            xQueueReceive(Controller_HeatingPassenger, &selectedHeatingIntensity, portMAX_DELAY);

            switch(selectedHeatingIntensity){
                case ERROR: /* 1011 */
                    GPIO_PORTB_DATA_REG = (GPIO_PORTB_DATA_REG & 0xF8) | 0x04;
                    break;

                case INTENSITYOFF:
                    GPIO_PORTB_DATA_REG = (GPIO_PORTB_DATA_REG & 0xF8) | 0x00;
                    break;

                case LOWINTENSITY: /* 1101 */
                    GPIO_PORTB_DATA_REG = (GPIO_PORTB_DATA_REG & 0xF8) | 0x02;
                    break;

                case MEDIUMINTENSITY:
                    GPIO_PORTB_DATA_REG = (GPIO_PORTB_DATA_REG & 0xF8) | 0x01;
                    break;

                case HIGHINTENSITY: /* 1100 */
                    GPIO_PORTB_DATA_REG = (GPIO_PORTB_DATA_REG & 0xF8) | 0x03;
                    break;
            }
        }
    }
}


void vDisplayTask(void *pvParameters){

    uint8 SeatSelect = (uint8)pvParameters;
    TickType_t xStartTime, xEndTime;
    uint8 DriverHeatState, DriverCurrentTemp;
    uint8 PassengerHeatState, PassengerCurrentTemp;

    UserHeatInput DriverHeatLevel, PassengerHeatLevel;

    for(;;){

        if(SeatSelect==ISDRIVER){
            if(     xQueueReceive(Reading_DisplayDriver   , DriverCurrentTemp, portMAX_DELAY) == pdTRUE ){   /* Receive Current Temp to Display */
                if( xQueueReceive(Controller_DisplayDriver, DriverHeatState  , portMAX_DELAY) == pdTRUE ){   /* Receive Heat State to Display */

                    xStartTime = xTaskGetTickCount();
                    if (xSemaphoreTake(DesiredTempMutexDriver, portMAX_DELAY) == pdTRUE){  /* Receive Heat Level to Display */
                        DriverHeatLevel = DesiredTempDriver;
                        xSemaphoreGive(DesiredTempMutexDriver);  /* Release the resource */
                    }
                    xEndTime = xTaskGetTickCount();
                    DesiredTempDisplayTaskDriverLT += xEndTime - xStartTime;


                    /********* DISPLAY ON SCREEN USING UART ********/
                    xStartTime = xTaskGetTickCount();
                    if (xSemaphoreTake(UARTMutex, portMAX_DELAY) == pdTRUE){   /* Receive Heat Level to Display */

                        UART0_SendString("\nCurrent Temp of Driver Seat is : ") ;
                        UART0_SendByte(DriverCurrentTemp);

                        UART0_SendString("\nHeat Level of Driver Seat is : ") ;
                        UART0_SendByte(DriverHeatLevel);

                        UART0_SendString("\nHeat State of Driver Seat is : ") ;
                        UART0_SendByte(DriverHeatState);

                        xSemaphoreGive(UARTMutex);  /* Release the resource */
                    }
                    xEndTime = xTaskGetTickCount();
                    UARTDisplayTaskDriverLT += xEndTime - xStartTime;

                }
            }
        }

        /*************** PASSENGER **************/
        else if(SeatSelect==ISPASSENGER){
            if(     xQueueReceive(Reading_DisplayPassenger   , PassengerCurrentTemp, portMAX_DELAY) == pdTRUE ){   /* Receive Current Temp to Display */
                if( xQueueReceive(Controller_DisplayPassenger, PassengerHeatState  , portMAX_DELAY) == pdTRUE ){   /* Receive Heat State to Display */


                    xStartTime = xTaskGetTickCount();
                    if (xSemaphoreTake(DesiredTempMutexPassenger , portMAX_DELAY) == pdTRUE){  /* Receive Heat Level to Display */
                        PassengerHeatLevel = DesiredTempPassenger;
                        xSemaphoreGive(DesiredTempMutexPassenger);  /* Release the resource */
                    }
                    xEndTime = xTaskGetTickCount();
                    DesiredTempDisplayTaskPassengerLT += xEndTime - xStartTime;


                    /********* DISPLAY ON SCREEN USING UART ********/
                    xStartTime = xTaskGetTickCount();
                    if (xSemaphoreTake(UARTMutex, portMAX_DELAY) == pdTRUE){   /* Receive Heat Level to Display */

                        UART0_SendString("\nCurrent Temp of Passenger Seat is : ") ;
                        UART0_SendByte(PassengerCurrentTemp);

                        UART0_SendString("\nHeat Level of Passenger Seat is : ") ;
                        UART0_SendByte(PassengerHeatLevel);

                        UART0_SendString("\nHeat State of Passenger Seat is : ") ;
                        UART0_SendByte(PassengerHeatState);

                        xSemaphoreGive(UARTMutex);  /* Release the resource */
                    }
                    xEndTime = xTaskGetTickCount();
                    UARTDisplayTaskPassengerLT += xEndTime - xStartTime;

                }
            }
        }

    }
}


void vRunTimeMeasurementsTask(void *pvParameters){

    const TickType_t xDelay = pdMS_TO_TICKS(1000);
    vTaskDelay(xDelay);

    TickType_t xStartTime, xEndTime;
    xStartTime = xTaskGetTickCount();

    if (xSemaphoreTake(UARTMutex, portMAX_DELAY) == pdTRUE) {

        UART0_SendString("\nTemperatureSettingTaskForDSeat execution time is ");
        UART0_SendInteger(ullTasksExecutionTime[2] / 10);
        UART0_SendString(" msec \r\n");

        UART0_SendString("\nTemperatureSettingTaskForPSeat execution time is ");
        UART0_SendInteger(ullTasksExecutionTime[3] / 10);
        UART0_SendString(" msec \r\n");

        UART0_SendString("\nTemperatureReadingTaskForDSeat execution time is ");
        UART0_SendInteger(ullTasksExecutionTime[4] / 10);
        UART0_SendString(" msec \r\n");

        UART0_SendString("\nTemperatureReadingTaskForPSeat execution time is ");
        UART0_SendInteger(ullTasksExecutionTime[5] / 10);
        UART0_SendString(" msec \r\n");

        UART0_SendString("\nHeating_CoolingTaskForDSeat execution time is ");
        UART0_SendInteger(ullTasksExecutionTime[6] / 10);
        UART0_SendString(" msec \r\n");

        UART0_SendString("\nHeating_CoolingTaskForPSeat execution time is ");
        UART0_SendInteger(ullTasksExecutionTime[7] / 10);
        UART0_SendString(" msec \r\n");

        UART0_SendString("\nDisplayTaskD execution time is ");
        UART0_SendInteger(ullTasksExecutionTime[8] / 10);
        UART0_SendString(" msec \r\n");

        UART0_SendString("\nDisplayTaskP execution time is ");
        UART0_SendInteger(ullTasksExecutionTime[9] / 10);
        UART0_SendString(" msec \r\n");

        UART0_SendString("\nSupervisorTaskD execution time is ");
        UART0_SendInteger(ullTasksExecutionTime[10] / 10);
        UART0_SendString(" msec \r\n");

        UART0_SendString("\nSupervisorTaskP execution time is ");
        UART0_SendInteger(ullTasksExecutionTime[11] / 10);
        UART0_SendString(" msec \r\n");

        xSemaphoreGive(UARTMutex);     /* Release the resource */
    }
    xEndTime = xTaskGetTickCount();
    UARTOneTimeRunTimeMeasurementsTaskLT=xEndTime - xStartTime;

    uint8 ucCounter, ucCPU_Load;
    uint32 ullTotalTasksTime = 0;

    TickType_t xLastWakeTime = xTaskGetTickCount();
    for (;;)
    {
         ullTotalTasksTime = 0;
        vTaskDelayUntil(&xLastWakeTime, RUNTIME_MEASUREMENTS_TASK_PERIODICITY);
        for(ucCounter = 1; ucCounter <= 11; ucCounter++){
            ullTotalTasksTime += ullTasksExecutionTime[ucCounter];
        }
        ucCPU_Load = (ullTotalTasksTime * 100) /  GPTM_WTimer0Read();
        TickType_t xStartTime, xEndTime;
        xStartTime = xTaskGetTickCount();
        if (xSemaphoreTake(UARTMutex, portMAX_DELAY) == pdTRUE) {
            UART0_SendString("CPU Load is ");
            UART0_SendInteger(ucCPU_Load);
            UART0_SendString("% \r\n");
            /* Release the peripheral */
            xSemaphoreGive(UARTMutex);
        }
        xEndTime = xTaskGetTickCount();
        UARTRunTimeMeasurementsTaskLT=xEndTime - xStartTime;
    }

}
